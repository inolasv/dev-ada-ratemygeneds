{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommaAndColonSeparatedRecord = exports.redactConnectionString = void 0;\n\nconst whatwg_url_1 = require(\"whatwg-url\");\n\nconst redact_1 = require(\"./redact\");\n\nObject.defineProperty(exports, \"redactConnectionString\", {\n  enumerable: true,\n  get: function () {\n    return redact_1.redactConnectionString;\n  }\n});\nconst DUMMY_HOSTNAME = '__this_is_a_placeholder__';\n\nfunction connectionStringHasValidScheme(connectionString) {\n  return connectionString.startsWith('mongodb://') || connectionString.startsWith('mongodb+srv://');\n}\n\nconst HOSTS_REGEX = new RegExp(String.raw`^(?<protocol>mongodb(?:\\+srv|)):\\/\\/(?:(?<username>[^:]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^\\/?@]*)(?<rest>.*)`);\n\nclass CaseInsensitiveMap extends Map {\n  delete(name) {\n    return super.delete(this._normalizeKey(name));\n  }\n\n  get(name) {\n    return super.get(this._normalizeKey(name));\n  }\n\n  has(name) {\n    return super.has(this._normalizeKey(name));\n  }\n\n  set(name, value) {\n    return super.set(this._normalizeKey(name), value);\n  }\n\n  _normalizeKey(name) {\n    name = `${name}`;\n\n    for (const key of this.keys()) {\n      if (key.toLowerCase() === name.toLowerCase()) {\n        name = key;\n        break;\n      }\n    }\n\n    return name;\n  }\n\n}\n\nfunction caseInsenstiveURLSearchParams(Ctor) {\n  return class CaseInsenstiveURLSearchParams extends Ctor {\n    append(name, value) {\n      return super.append(this._normalizeKey(name), value);\n    }\n\n    delete(name) {\n      return super.delete(this._normalizeKey(name));\n    }\n\n    get(name) {\n      return super.get(this._normalizeKey(name));\n    }\n\n    getAll(name) {\n      return super.getAll(this._normalizeKey(name));\n    }\n\n    has(name) {\n      return super.has(this._normalizeKey(name));\n    }\n\n    set(name, value) {\n      return super.set(this._normalizeKey(name), value);\n    }\n\n    keys() {\n      return super.keys();\n    }\n\n    values() {\n      return super.values();\n    }\n\n    entries() {\n      return super.entries();\n    }\n\n    [Symbol.iterator]() {\n      return super[Symbol.iterator]();\n    }\n\n    _normalizeKey(name) {\n      return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);\n    }\n\n  };\n}\n\nclass URLWithoutHost extends whatwg_url_1.URL {}\n\nclass MongoParseError extends Error {\n  get name() {\n    return 'MongoParseError';\n  }\n\n}\n\nclass ConnectionString extends URLWithoutHost {\n  constructor(uri) {\n    var _a;\n\n    if (!connectionStringHasValidScheme(uri)) {\n      throw new MongoParseError('Invalid scheme, expected connection string to start with \"mongodb://\" or \"mongodb+srv://\"');\n    }\n\n    const match = uri.match(HOSTS_REGEX);\n\n    if (!match) {\n      throw new MongoParseError(`Invalid connection string \"${uri}\"`);\n    }\n\n    const {\n      protocol,\n      username,\n      password,\n      hosts,\n      rest\n    } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};\n\n    if (!protocol || !hosts) {\n      throw new MongoParseError(`Protocol and host list are required in \"${uri}\"`);\n    }\n\n    try {\n      decodeURIComponent(username !== null && username !== void 0 ? username : '');\n      decodeURIComponent(password !== null && password !== void 0 ? password : '');\n    } catch (err) {\n      throw new MongoParseError(err.message);\n    }\n\n    const illegalCharacters = new RegExp(String.raw`[:/?#\\[\\]@]`, 'gi');\n\n    if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {\n      throw new MongoParseError(`Username contains unescaped characters ${username}`);\n    }\n\n    if (!username || !password) {\n      const uriWithoutProtocol = uri.replace(`${protocol}://`, '');\n\n      if (uriWithoutProtocol.startsWith('@') || uriWithoutProtocol.startsWith(':')) {\n        throw new MongoParseError('URI contained empty userinfo section');\n      }\n    }\n\n    if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {\n      throw new MongoParseError('Password contains unescaped characters');\n    }\n\n    let authString = '';\n    if (typeof username === 'string') authString += username;\n    if (typeof password === 'string') authString += `:${password}`;\n    if (authString) authString += '@';\n    super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);\n    this._hosts = hosts.split(',');\n\n    if (this.isSRV && this.hosts.length !== 1) {\n      throw new MongoParseError('mongodb+srv URI cannot have multiple service names');\n    }\n\n    if (this.isSRV && this.hosts.some(host => host.includes(':'))) {\n      throw new MongoParseError('mongodb+srv URI cannot have port number');\n    }\n\n    if (!this.pathname) {\n      this.pathname = '/';\n    }\n\n    Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);\n  }\n\n  get host() {\n    return DUMMY_HOSTNAME;\n  }\n\n  set host(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get hostname() {\n    return DUMMY_HOSTNAME;\n  }\n\n  set hostname(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get port() {\n    return '';\n  }\n\n  set port(_ignored) {\n    throw new Error('No single host for connection string');\n  }\n\n  get href() {\n    return this.toString();\n  }\n\n  set href(_ignored) {\n    throw new Error('Cannot set href for connection strings');\n  }\n\n  get isSRV() {\n    return this.protocol.includes('srv');\n  }\n\n  get hosts() {\n    return this._hosts;\n  }\n\n  set hosts(list) {\n    this._hosts = list;\n  }\n\n  toString() {\n    return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(','));\n  }\n\n  clone() {\n    return new ConnectionString(this.toString());\n  }\n\n  redact(options) {\n    return (0, redact_1.redactValidConnectionString)(this, options);\n  }\n\n  typedSearchParams() {\n    const sametype = false && new (caseInsenstiveURLSearchParams(whatwg_url_1.URLSearchParams))();\n    return this.searchParams;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    const {\n      href,\n      origin,\n      protocol,\n      username,\n      password,\n      hosts,\n      pathname,\n      search,\n      searchParams,\n      hash\n    } = this;\n    return {\n      href,\n      origin,\n      protocol,\n      username,\n      password,\n      hosts,\n      pathname,\n      search,\n      searchParams,\n      hash\n    };\n  }\n\n}\n\nexports.default = ConnectionString;\n\nclass CommaAndColonSeparatedRecord extends CaseInsensitiveMap {\n  constructor(from) {\n    super();\n\n    for (const entry of (from !== null && from !== void 0 ? from : '').split(',')) {\n      if (!entry) continue;\n      const colonIndex = entry.indexOf(':');\n\n      if (colonIndex === -1) {\n        this.set(entry, '');\n      } else {\n        this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));\n      }\n    }\n  }\n\n  toString() {\n    return [...this].map(entry => entry.join(':')).join(',');\n  }\n\n}\n\nexports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;","map":null,"metadata":{},"sourceType":"script"}