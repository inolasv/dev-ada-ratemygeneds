{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesCursor = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\n\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst execute_operation_1 = require(\"./execute_operation\");\n\nconst operation_1 = require(\"./operation\");\n\nconst LIST_INDEXES_WIRE_VERSION = 3;\nconst VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version', // text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion', // 2d-sphere indexes\n'2dsphereIndexVersion', // 2d indexes\n'bits', 'min', 'max', // geoHaystack Indexes\n'bucketSize', // wildcard indexes\n'wildcardProjection']);\n\nfunction makeIndexSpec(indexSpec, options) {\n  const indexParameters = (0, utils_1.parseIndexOptions)(indexSpec); // Generate the index name\n\n  const name = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const finalIndexSpec = {\n    name,\n    key: indexParameters.fieldHash\n  }; // merge valid index options into the index spec\n\n  for (const optionName in options) {\n    if (VALID_INDEX_OPTIONS.has(optionName)) {\n      finalIndexSpec[optionName] = options[optionName];\n    }\n  }\n\n  return finalIndexSpec;\n}\n/** @internal */\n\n\nclass IndexesOperation extends operation_1.AbstractOperation {\n  constructor(collection, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = this.options;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, {\n      full: true,\n      ...options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\n\nclass CreateIndexesOperation extends command_1.CommandOperation {\n  constructor(parent, collectionName, indexes, options) {\n    super(parent, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionName = collectionName;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const indexes = this.indexes;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server); // Ensure we generate the correct name if the parameter is not set\n\n    for (let i = 0; i < indexes.length; i++) {\n      // Did the user pass in a collation, check if our write server supports it\n      if (indexes[i].collation && serverWireVersion < 5) {\n        callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, ` + 'does not support collation'));\n        return;\n      }\n\n      if (indexes[i].name == null) {\n        const keys = [];\n\n        for (const name in indexes[i].key) {\n          keys.push(`${name}_${indexes[i].key[name]}`);\n        } // Set the name\n\n\n        indexes[i].name = keys.join('_');\n      }\n    }\n\n    const cmd = {\n      createIndexes: this.collectionName,\n      indexes\n    };\n\n    if (options.commitQuorum != null) {\n      if (serverWireVersion < 9) {\n        callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n        return;\n      }\n\n      cmd.commitQuorum = options.commitQuorum;\n    } // collation is set on each index, it should not be defined at the root\n\n\n    this.options.collation = undefined;\n    super.executeCommand(server, session, cmd, err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const indexNames = indexes.map(index => index.name || '');\n      callback(undefined, indexNames);\n    });\n  }\n\n}\n\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\n\nclass CreateIndexOperation extends CreateIndexesOperation {\n  constructor(parent, collectionName, indexSpec, options) {\n    // createIndex can be called with a variety of styles:\n    //   coll.createIndex('a');\n    //   coll.createIndex({ a: 1 });\n    //   coll.createIndex([['a', 1]]);\n    // createIndexes is always called with an array of index spec objects\n    super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, indexNames) => {\n      if (err || !indexNames) return callback(err);\n      return callback(undefined, indexNames[0]);\n    });\n  }\n\n}\n\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\n\nclass EnsureIndexOperation extends CreateIndexOperation {\n  constructor(db, collectionName, indexSpec, options) {\n    super(db, collectionName, indexSpec, options);\n    this.readPreference = read_preference_1.ReadPreference.primary;\n    this.db = db;\n    this.collectionName = collectionName;\n  }\n\n  execute(server, session, callback) {\n    const indexName = this.indexes[0].name;\n    const cursor = this.db.collection(this.collectionName).listIndexes({\n      session\n    });\n    cursor.toArray((err, indexes) => {\n      /// ignore \"NamespaceNotFound\" errors\n      if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        return callback(err);\n      }\n\n      if (indexes) {\n        indexes = Array.isArray(indexes) ? indexes : [indexes];\n\n        if (indexes.some(index => index.name === indexName)) {\n          callback(undefined, indexName);\n          return;\n        }\n      }\n\n      super.execute(server, session, callback);\n    });\n  }\n\n}\n\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\n\nclass DropIndexOperation extends command_1.CommandOperation {\n  constructor(collection, indexName, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collection = collection;\n    this.indexName = indexName;\n  }\n\n  execute(server, session, callback) {\n    const cmd = {\n      dropIndexes: this.collection.collectionName,\n      index: this.indexName\n    };\n    super.executeCommand(server, session, cmd, callback);\n  }\n\n}\n\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\n\nclass DropIndexesOperation extends DropIndexOperation {\n  constructor(collection, options) {\n    super(collection, '*', options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, err => {\n      if (err) return callback(err, false);\n      callback(undefined, true);\n    });\n  }\n\n}\n\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\n\nclass ListIndexesOperation extends command_1.CommandOperation {\n  constructor(collection, options) {\n    super(collection, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.collectionNamespace = collection.s.namespace;\n  }\n\n  execute(server, session, callback) {\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n\n    if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {\n      const systemIndexesNS = this.collectionNamespace.withCollection('system.indexes');\n      const collectionNS = this.collectionNamespace.toString();\n      server.query(systemIndexesNS, {\n        query: {\n          ns: collectionNS\n        }\n      }, { ...this.options,\n        readPreference: this.readPreference\n      }, callback);\n      return;\n    }\n\n    const cursor = this.options.batchSize ? {\n      batchSize: this.options.batchSize\n    } : {};\n    super.executeCommand(server, session, {\n      listIndexes: this.collectionNamespace.collection,\n      cursor\n    }, callback);\n  }\n\n}\n\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @public */\n\nclass ListIndexesCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(collection, options) {\n    super((0, utils_1.getTopology)(collection), collection.s.namespace, options);\n    this.parent = collection;\n    this.options = options;\n  }\n\n  clone() {\n    return new ListIndexesCursor(this.parent, { ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const operation = new ListIndexesOperation(this.parent, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n\n}\n\nexports.ListIndexesCursor = ListIndexesCursor;\n/** @internal */\n\nclass IndexExistsOperation extends operation_1.AbstractOperation {\n  constructor(collection, indexes, options) {\n    super(options);\n    this.options = options;\n    this.collection = collection;\n    this.indexes = indexes;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const indexes = this.indexes;\n    (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, (err, indexInformation) => {\n      // If we have an error return\n      if (err != null) return callback(err); // Let's check for the index names\n\n      if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null); // Check in list of indexes\n\n      for (let i = 0; i < indexes.length; i++) {\n        if (indexInformation[indexes[i]] == null) {\n          return callback(undefined, false);\n        }\n      } // All keys found return true\n\n\n      return callback(undefined, true);\n    });\n  }\n\n}\n\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\n\nclass IndexInformationOperation extends operation_1.AbstractOperation {\n  constructor(db, name, options) {\n    super(options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    const db = this.db;\n    const name = this.name;\n    (0, common_functions_1.indexInformation)(db, name, { ...this.options,\n      readPreference: this.readPreference,\n      session\n    }, callback);\n  }\n\n}\n\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":null,"metadata":{},"sourceType":"script"}