{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst commands_1 = require(\"./commands\");\n\nconst compression_1 = require(\"./wire_protocol/compression\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\n\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\n\nclass MessageStream extends stream_1.Duplex {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read() {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    (0, compression_1.compress)({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n}\n\nexports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  (0, compression_1.decompress)(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}