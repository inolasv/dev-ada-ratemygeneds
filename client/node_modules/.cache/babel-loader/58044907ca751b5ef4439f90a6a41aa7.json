{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineAspects = exports.AbstractOperation = exports.Aspect = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nexports.Aspect = {\n  READ_OPERATION: Symbol('READ_OPERATION'),\n  WRITE_OPERATION: Symbol('WRITE_OPERATION'),\n  RETRYABLE: Symbol('RETRYABLE'),\n  EXPLAINABLE: Symbol('EXPLAINABLE'),\n  SKIP_COLLATION: Symbol('SKIP_COLLATION'),\n  CURSOR_CREATING: Symbol('CURSOR_CREATING'),\n  CURSOR_ITERATING: Symbol('CURSOR_ITERATING')\n};\n/** @internal */\n\nconst kSession = Symbol('session');\n/**\n * This class acts as a parent class for any operation and is responsible for setting this.options,\n * as well as setting and getting a session.\n * Additionally, this class implements `hasAspect`, which determines whether an operation has\n * a specific aspect.\n * @internal\n */\n\nclass AbstractOperation {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a;\n\n    this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : (_a = read_preference_1.ReadPreference.fromOptions(options)) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary; // Pull the BSON serialize options from the already-resolved options\n\n    this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);\n\n    if (options.session) {\n      this[kSession] = options.session;\n    }\n\n    this.options = options;\n    this.bypassPinningCheck = !!options.bypassPinningCheck;\n    this.trySecondaryWrite = false;\n  }\n\n  hasAspect(aspect) {\n    const ctor = this.constructor;\n\n    if (ctor.aspects == null) {\n      return false;\n    }\n\n    return ctor.aspects.has(aspect);\n  }\n\n  get session() {\n    return this[kSession];\n  }\n\n  get canRetryRead() {\n    return true;\n  }\n\n  get canRetryWrite() {\n    return true;\n  }\n\n}\n\nexports.AbstractOperation = AbstractOperation;\n\nfunction defineAspects(operation, aspects) {\n  if (!Array.isArray(aspects) && !(aspects instanceof Set)) {\n    aspects = [aspects];\n  }\n\n  aspects = new Set(aspects);\n  Object.defineProperty(operation, 'aspects', {\n    value: aspects,\n    writable: false\n  });\n  return aspects;\n}\n\nexports.defineAspects = defineAspects;","map":null,"metadata":{},"sourceType":"script"}