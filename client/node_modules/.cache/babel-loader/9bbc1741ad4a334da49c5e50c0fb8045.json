{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst commands_1 = require(\"./commands\");\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kHello = Symbol('hello');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    })); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get hello() {\n    return this[kHello];\n  } // the `connect` method stores the result of the handshake hello on the connection\n\n\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kHello] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.hello == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  /** @internal */\n\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n  /** @internal */\n\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n  /** @internal */\n\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, { ...(0, bson_1.pluckBSONSerializeOptions)(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  /** @internal */\n\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if ((0, utils_1.maxWireVersion)(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}