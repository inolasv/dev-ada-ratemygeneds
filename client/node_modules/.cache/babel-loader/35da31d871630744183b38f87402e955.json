{"ast":null,"code":"\"use strict\";\n\nconst urlencoded = require(\"./urlencoded\");\n\nexports.implementation = class URLSearchParamsImpl {\n  constructor(globalObject, constructorArgs, _ref) {\n    let {\n      doNotStripQMark = false\n    } = _ref;\n    let init = constructorArgs[0];\n    this._list = [];\n    this._url = null;\n\n    if (!doNotStripQMark && typeof init === \"string\" && init[0] === \"?\") {\n      init = init.slice(1);\n    }\n\n    if (Array.isArray(init)) {\n      for (const pair of init) {\n        if (pair.length !== 2) {\n          throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1 sequence's element does not \" + \"contain exactly two elements.\");\n        }\n\n        this._list.push([pair[0], pair[1]]);\n      }\n    } else if (typeof init === \"object\" && Object.getPrototypeOf(init) === null) {\n      for (const name of Object.keys(init)) {\n        const value = init[name];\n\n        this._list.push([name, value]);\n      }\n    } else {\n      this._list = urlencoded.parseUrlencodedString(init);\n    }\n  }\n\n  _updateSteps() {\n    if (this._url !== null) {\n      let query = urlencoded.serializeUrlencoded(this._list);\n\n      if (query === \"\") {\n        query = null;\n      }\n\n      this._url._url.query = query;\n    }\n  }\n\n  append(name, value) {\n    this._list.push([name, value]);\n\n    this._updateSteps();\n  }\n\n  delete(name) {\n    let i = 0;\n\n    while (i < this._list.length) {\n      if (this._list[i][0] === name) {\n        this._list.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    this._updateSteps();\n  }\n\n  get(name) {\n    for (const tuple of this._list) {\n      if (tuple[0] === name) {\n        return tuple[1];\n      }\n    }\n\n    return null;\n  }\n\n  getAll(name) {\n    const output = [];\n\n    for (const tuple of this._list) {\n      if (tuple[0] === name) {\n        output.push(tuple[1]);\n      }\n    }\n\n    return output;\n  }\n\n  has(name) {\n    for (const tuple of this._list) {\n      if (tuple[0] === name) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  set(name, value) {\n    let found = false;\n    let i = 0;\n\n    while (i < this._list.length) {\n      if (this._list[i][0] === name) {\n        if (found) {\n          this._list.splice(i, 1);\n        } else {\n          found = true;\n          this._list[i][1] = value;\n          i++;\n        }\n      } else {\n        i++;\n      }\n    }\n\n    if (!found) {\n      this._list.push([name, value]);\n    }\n\n    this._updateSteps();\n  }\n\n  sort() {\n    this._list.sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n\n      if (a[0] > b[0]) {\n        return 1;\n      }\n\n      return 0;\n    });\n\n    this._updateSteps();\n  }\n\n  [Symbol.iterator]() {\n    return this._list[Symbol.iterator]();\n  }\n\n  toString() {\n    return urlencoded.serializeUrlencoded(this._list);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}