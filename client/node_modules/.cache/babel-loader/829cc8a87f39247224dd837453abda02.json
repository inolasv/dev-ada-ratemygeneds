{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Db = void 0;\n\nconst admin_1 = require(\"./admin\");\n\nconst bson_1 = require(\"./bson\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst collection_1 = require(\"./collection\");\n\nconst CONSTANTS = require(\"./constants\");\n\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\n\nconst error_1 = require(\"./error\");\n\nconst logger_1 = require(\"./logger\");\n\nconst add_user_1 = require(\"./operations/add_user\");\n\nconst collections_1 = require(\"./operations/collections\");\n\nconst create_collection_1 = require(\"./operations/create_collection\");\n\nconst drop_1 = require(\"./operations/drop\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst indexes_1 = require(\"./operations/indexes\");\n\nconst list_collections_1 = require(\"./operations/list_collections\");\n\nconst profiling_level_1 = require(\"./operations/profiling_level\");\n\nconst remove_user_1 = require(\"./operations/remove_user\");\n\nconst rename_1 = require(\"./operations/rename\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst set_profiling_level_1 = require(\"./operations/set_profiling_level\");\n\nconst stats_1 = require(\"./operations/stats\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst utils_1 = require(\"./utils\");\n\nconst write_concern_1 = require(\"./write_concern\"); // Allowed parameters\n\n\nconst DB_OPTIONS_ALLOW_LIST = ['writeConcern', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'authSource', 'ignoreUndefined', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'bsonRegExp', 'enableUtf8Validation', 'promoteValues', 'compression', 'retryWrites'];\n/**\n * The **Db** class is a class that represents a MongoDB Database.\n * @public\n *\n * @example\n * ```js\n * const { MongoClient } = require('mongodb');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Select the database by name\n *   const testDb = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nclass Db {\n  /**\n   * Creates a new Db instance\n   *\n   * @param client - The MongoClient for the database.\n   * @param databaseName - The name of the database this instance represents.\n   * @param options - Optional settings for Db construction\n   */\n  constructor(client, databaseName, options) {\n    var _a;\n\n    options = options !== null && options !== void 0 ? options : {}; // Filter the options\n\n    options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST); // Ensure we have a valid db name\n\n    validateDatabaseName(databaseName); // Internal state of the db object\n\n    this.s = {\n      // Client\n      client,\n      // Options\n      options,\n      // Logger instance\n      logger: new logger_1.Logger('Db', options),\n      // Unpack read preference\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      // Merge bson options\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),\n      // Set up the primary key factory or fallback to ObjectId\n      pkFactory: (_a = options === null || options === void 0 ? void 0 : options.pkFactory) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PK_FACTORY,\n      // ReadConcern\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      // Namespace\n      namespace: new utils_1.MongoDBNamespace(databaseName)\n    };\n  }\n\n  get databaseName() {\n    return this.s.namespace.db;\n  } // Options\n\n\n  get options() {\n    return this.s.options;\n  }\n  /**\n   * slaveOk specified\n   * @deprecated Use secondaryOk instead\n   */\n\n\n  get slaveOk() {\n    return this.secondaryOk;\n  }\n  /**\n   * Check if a secondary can be used (because the read preference is *not* set to primary)\n   */\n\n\n  get secondaryOk() {\n    var _a;\n\n    return ((_a = this.s.readPreference) === null || _a === void 0 ? void 0 : _a.preference) !== 'primary' || false;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the Db. If not explicitly defined for\n   * this Db, will be inherited from the parent MongoClient\n   */\n\n\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.client.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  } // get the write Concern\n\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n\n  createCollection(name, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  command(command, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new run_command_1.RunCommandOperation(this, command, options !== null && options !== void 0 ? options : {}), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the database, needs MongoDB \\>= 3.6\n   *\n   * @param pipeline - An array of aggregation stages to be executed\n   * @param options - Optional settings for the command\n   */\n\n\n  aggregate() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"db.aggregate()\" accepts at most two arguments');\n    }\n\n    if (typeof pipeline === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must not be function');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new aggregation_cursor_1.AggregationCursor((0, utils_1.getTopology)(this), this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Return the Admin db instance */\n\n\n  admin() {\n    return new admin_1.Admin(this);\n  }\n  /**\n   * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.\n   *\n   * @param name - the collection name we wish to access.\n   * @returns return the new Collection instance\n   */\n\n\n  collection(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');\n    }\n\n    const finalOptions = (0, utils_1.resolveOptions)(this, options);\n    return new collection_1.Collection(this, name, finalOptions);\n  }\n\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  listCollections() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new list_collections_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));\n  }\n\n  renameCollection(fromCollection, toCollection, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    options = { ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }; // Add return new collection\n\n    options.new_collection = true;\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new rename_1.RenameOperation(this.collection(fromCollection), toCollection, options), callback);\n  }\n\n  dropCollection(name, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  dropDatabase(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  collections(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  createIndex(name, indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  addUser(username, password, options, callback) {\n    if (typeof password === 'function') {\n      callback = password, password = undefined, options = {};\n    } else if (typeof password !== 'string') {\n      if (typeof options === 'function') {\n        callback = options, options = password, password = undefined;\n      } else {\n        options = password, callback = undefined, password = undefined;\n      }\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  removeUser(username, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  setProfilingLevel(level, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  profilingLevel(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n\n  indexInformation(name, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this), new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n  }\n  /**\n   * Unref all sockets\n   * @deprecated This function is deprecated and will be removed in the next major version.\n   */\n\n\n  unref() {\n    (0, utils_1.getTopology)(this).unref();\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this database. Will ignore all\n   * changes to system collections.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Return the db logger */\n\n\n  getLogger() {\n    return this.s.logger;\n  }\n\n  get logger() {\n    return this.s.logger;\n  }\n\n}\n\nexports.Db = Db;\nDb.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;\nDb.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;\nDb.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;\nDb.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;\nDb.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;\nDb.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION; // TODO(NODE-3484): Refactor into MongoDBNamespace\n// Validate the database name\n\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw new error_1.MongoInvalidArgumentError('Database name must be a string');\n  if (databaseName.length === 0) throw new error_1.MongoInvalidArgumentError('Database name cannot be the empty string');\n  if (databaseName === '$external') return;\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\n\n  for (let i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw new error_1.MongoAPIError(`database names cannot contain the character '${invalidChars[i]}'`);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}