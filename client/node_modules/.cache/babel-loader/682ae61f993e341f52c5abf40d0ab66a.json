{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst connection_string_1 = require(\"./connection_string\");\n\nconst db_1 = require(\"./db\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst connect_1 = require(\"./operations/connect\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst utils_1 = require(\"./utils\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const client = this; // The internal state\n\n    this.s = {\n      url,\n      sessions: new Set(),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get logger() {\n        return client[kOptions].logger;\n      }\n\n    };\n  }\n\n  get options() {\n    return Object.freeze({ ...this[kOptions]\n    });\n  }\n\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n\n\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get readPreference() {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n\n  get logger() {\n    return this.s.logger;\n  }\n\n  connect(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n\n    return (0, utils_1.maybePromise)(callback, cb => {\n      (0, connect_1.connect)(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n\n  close(forceOrCallback, callback) {\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return (0, utils_1.maybePromise)(callback, callback => {\n      if (this.topology == null) {\n        return callback();\n      } // clear out references to old topology\n\n\n      const topology = this.topology;\n      this.topology = undefined;\n      topology.close({\n        force\n      }, error => {\n        if (error) return callback(error);\n        const {\n          encrypter\n        } = this[kOptions];\n\n        if (encrypter) {\n          return encrypter.close(this, force, error => {\n            callback(error);\n          });\n        }\n\n        callback();\n      });\n    });\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n\n\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided\n\n    if (!dbName) {\n      dbName = this.options.dbName;\n    } // Copy the options and add out internal override of the not shared flag\n\n\n    const finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n    const db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n    return db;\n  }\n\n  static connect(url, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options); // Execute the connect method\n\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n    }\n  }\n\n  startSession(options) {\n    options = Object.assign({\n      explicit: true\n    }, options);\n\n    if (!this.topology) {\n      throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n    }\n\n    return this.topology.startSession(options, this.s.options);\n  }\n\n  withSession(optionsOrOperation, callback) {\n    let options = optionsOrOperation;\n\n    if (typeof optionsOrOperation === 'function') {\n      callback = optionsOrOperation;\n      options = {\n        owner: Symbol()\n      };\n    }\n\n    if (callback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n\n    const session = this.startSession(options);\n    const Promise = promise_provider_1.PromiseProvider.get();\n\n    let cleanupHandler = (err, result, opts) => {\n      // prevent multiple calls to cleanupHandler\n      cleanupHandler = () => {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n      };\n\n      opts = Object.assign({\n        throw: true\n      }, opts);\n      session.endSession();\n\n      if (err) {\n        if (opts.throw) throw err;\n        return Promise.reject(err);\n      }\n    };\n\n    try {\n      const result = callback(session);\n      return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, {\n        throw: true\n      }));\n    } catch (err) {\n      return cleanupHandler(err, null, {\n        throw: false\n      });\n    }\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch() {\n    let pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n  }\n  /** Return the mongo client logger */\n\n\n  getLogger() {\n    return this.s.logger;\n  }\n\n}\n\nexports.MongoClient = MongoClient;","map":null,"metadata":{},"sourceType":"script"}