{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FindOperation = void 0;\n\nconst shared_1 = require(\"../cmap/wire_protocol/shared\");\n\nconst error_1 = require(\"../error\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst sort_1 = require(\"../sort\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n\nconst SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;\n/** @internal */\n\nclass FindOperation extends command_1.CommandOperation {\n  constructor(collection, ns) {\n    let filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(collection, options);\n    this.options = options;\n    this.ns = ns;\n\n    if (typeof filter !== 'object' || Array.isArray(filter)) {\n      throw new error_1.MongoInvalidArgumentError('Query filter must be a plain object or ObjectId');\n    } // If the filter is a buffer, validate that is a valid BSON document\n\n\n    if (Buffer.isBuffer(filter)) {\n      const objectSize = filter[0] | filter[1] << 8 | filter[2] << 16 | filter[3] << 24;\n\n      if (objectSize !== filter.length) {\n        throw new error_1.MongoInvalidArgumentError(`Query filter raw message size does not match message header size [${filter.length}] != [${objectSize}]`);\n      }\n    } // special case passing in an ObjectId as a filter\n\n\n    this.filter = filter != null && filter._bsontype === 'ObjectID' ? {\n      _id: filter\n    } : filter;\n  }\n\n  execute(server, session, callback) {\n    this.server = server;\n    const serverWireVersion = (0, utils_1.maxWireVersion)(server);\n    const options = this.options;\n\n    if (options.allowDiskUse != null && serverWireVersion < 4) {\n      callback(new error_1.MongoCompatibilityError('Option \"allowDiskUse\" is not supported on MongoDB < 3.2'));\n      return;\n    }\n\n    if (options.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {\n      callback(new error_1.MongoCompatibilityError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));\n      return;\n    }\n\n    if (serverWireVersion < 4) {\n      if (this.readConcern && this.readConcern.level !== 'local') {\n        callback(new error_1.MongoCompatibilityError(`Server find command does not support a readConcern level of ${this.readConcern.level}`));\n        return;\n      }\n\n      const findCommand = makeLegacyFindCommand(this.ns, this.filter, options);\n\n      if ((0, shared_1.isSharded)(server) && this.readPreference) {\n        findCommand.$readPreference = this.readPreference.toJSON();\n      }\n\n      server.query(this.ns, findCommand, { ...this.options,\n        ...this.bsonOptions,\n        documentsReturnedIn: 'firstBatch',\n        readPreference: this.readPreference\n      }, callback);\n      return;\n    }\n\n    let findCommand = makeFindCommand(this.ns, this.filter, options);\n\n    if (this.explain) {\n      findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);\n    }\n\n    server.command(this.ns, findCommand, { ...this.options,\n      ...this.bsonOptions,\n      documentsReturnedIn: 'firstBatch',\n      session\n    }, callback);\n  }\n\n}\n\nexports.FindOperation = FindOperation;\n\nfunction makeFindCommand(ns, filter, options) {\n  const findCommand = {\n    find: ns.collection,\n    filter\n  };\n\n  if (options.sort) {\n    findCommand.sort = (0, sort_1.formatSort)(options.sort);\n  }\n\n  if (options.projection) {\n    let projection = options.projection;\n\n    if (projection && Array.isArray(projection)) {\n      projection = projection.length ? projection.reduce((result, field) => {\n        result[field] = 1;\n        return result;\n      }, {}) : {\n        _id: 1\n      };\n    }\n\n    findCommand.projection = projection;\n  }\n\n  if (options.hint) {\n    findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);\n  }\n\n  if (typeof options.skip === 'number') {\n    findCommand.skip = options.skip;\n  }\n\n  if (typeof options.limit === 'number') {\n    if (options.limit < 0) {\n      findCommand.limit = -options.limit;\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.limit = options.limit;\n    }\n  }\n\n  if (typeof options.batchSize === 'number') {\n    if (options.batchSize < 0) {\n      if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {\n        findCommand.limit = -options.batchSize;\n      }\n\n      findCommand.singleBatch = true;\n    } else {\n      findCommand.batchSize = options.batchSize;\n    }\n  }\n\n  if (typeof options.singleBatch === 'boolean') {\n    findCommand.singleBatch = options.singleBatch;\n  }\n\n  if (options.comment) {\n    findCommand.comment = options.comment;\n  }\n\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.maxTimeMS = options.maxTimeMS;\n  }\n\n  const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n  if (readConcern) {\n    findCommand.readConcern = readConcern.toJSON();\n  }\n\n  if (options.max) {\n    findCommand.max = options.max;\n  }\n\n  if (options.min) {\n    findCommand.min = options.min;\n  }\n\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.returnKey = options.returnKey;\n  }\n\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.showRecordId = options.showRecordId;\n  }\n\n  if (typeof options.tailable === 'boolean') {\n    findCommand.tailable = options.tailable;\n  }\n\n  if (typeof options.timeout === 'boolean') {\n    findCommand.noCursorTimeout = !options.timeout;\n  } else if (typeof options.noCursorTimeout === 'boolean') {\n    findCommand.noCursorTimeout = options.noCursorTimeout;\n  }\n\n  if (typeof options.awaitData === 'boolean') {\n    findCommand.awaitData = options.awaitData;\n  }\n\n  if (typeof options.allowPartialResults === 'boolean') {\n    findCommand.allowPartialResults = options.allowPartialResults;\n  }\n\n  if (options.collation) {\n    findCommand.collation = options.collation;\n  }\n\n  if (typeof options.allowDiskUse === 'boolean') {\n    findCommand.allowDiskUse = options.allowDiskUse;\n  }\n\n  if (options.let) {\n    findCommand.let = options.let;\n  }\n\n  return findCommand;\n}\n\nfunction makeLegacyFindCommand(ns, filter, options) {\n  const findCommand = {\n    $query: filter\n  };\n\n  if (options.sort) {\n    findCommand.$orderby = (0, sort_1.formatSort)(options.sort);\n  }\n\n  if (options.hint) {\n    findCommand.$hint = (0, utils_1.normalizeHintField)(options.hint);\n  }\n\n  if (typeof options.returnKey === 'boolean') {\n    findCommand.$returnKey = options.returnKey;\n  }\n\n  if (options.max) {\n    findCommand.$max = options.max;\n  }\n\n  if (options.min) {\n    findCommand.$min = options.min;\n  }\n\n  if (typeof options.showRecordId === 'boolean') {\n    findCommand.$showDiskLoc = options.showRecordId;\n  }\n\n  if (options.comment) {\n    findCommand.$comment = options.comment;\n  }\n\n  if (typeof options.maxTimeMS === 'number') {\n    findCommand.$maxTimeMS = options.maxTimeMS;\n  }\n\n  if (options.explain != null) {\n    findCommand.$explain = true;\n  }\n\n  return findCommand;\n}\n\n(0, operation_1.defineAspects)(FindOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":null,"metadata":{},"sourceType":"script"}